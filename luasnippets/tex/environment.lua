-- Abbreviations used in this article and the LuaSnip docs
local ls = require("luasnip")
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local d = ls.dynamic_node
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local rep = require("luasnip.extras").rep

-- TEST
-- local util = require("luasnip.util.util")
-- local node_util = require("luasnip.nodes.util")
--
-- local function find_dynamic_node(node)
-- 	-- the dynamicNode-key is set on snippets generated by a dynamicNode only (its'
-- 	-- actual use is to refer to the dynamicNode that generated the snippet).
-- 	while not node.dynamicNode do
-- 		node = node.parent
-- 	end
-- 	return node.dynamicNode
-- end
--
-- local external_update_id = 0
-- -- func_indx to update the dynamicNode with different functions.
-- function dynamic_node_external_update(func_indx)
-- 	-- most of this function is about restoring the cursor to the correct
-- 	-- position+mode, the important part are the few lines from
-- 	-- `dynamic_node.snip:store()`.
--
--
-- 	-- find current node and the innermost dynamicNode it is inside.
-- 	local current_node = ls.session.current_nodes[vim.api.nvim_get_current_buf()]
-- 	local dynamic_node = find_dynamic_node(current_node)
--
-- 	-- to identify current node in new snippet, if it is available.
-- 	external_update_id = external_update_id + 1
-- 	current_node.external_update_id = external_update_id
-- 	local current_node_key = current_node.key
--
-- 	-- store which mode we're in to restore later.
-- 	local insert_pre_call = vim.fn.mode() == "i"
-- 	-- is byte-indexed! Doesn't matter here, but important to be aware of.
-- 	local cursor_pos_end_relative = util.pos_sub(
-- 		util.get_cursor_0ind(),
-- 		current_node.mark:get_endpoint(1)
-- 	)
--
-- 	-- leave current generated snippet.
-- 	node_util.leave_nodes_between(dynamic_node.snip, current_node)
--
-- 	-- call update-function.
-- 	local func = dynamic_node.user_args[func_indx]
-- 	if func then
-- 		-- the same snippet passed to the dynamicNode-function. Any output from func
-- 		-- should be stored in it under some unused key.
-- 		func(dynamic_node.parent.snippet)
-- 	end
--
-- 	-- last_args is used to store the last args that were used to generate the
-- 	-- snippet. If this function is called, these will most probably not have
-- 	-- changed, so they are set to nil, which will force an update.
-- 	dynamic_node.last_args = nil
-- 	dynamic_node:update()
--
-- 	-- everything below here isn't strictly necessary, but it's pretty nice to have.
--
--
--     -- try to find the node we marked earlier, or a node with the same key.
--     -- Both are getting equal priority here, it might make sense to give "exact
--     -- same node" higher priority by doing two searches (but that would require
--     -- two searches :( )
-- 	local target_node = dynamic_node:find_node(function(test_node)
-- 		return (test_node.external_update_id == external_update_id) or (current_node_key ~= nil and test_node.key == current_node_key)
-- 	end)
--
-- 	if target_node then
-- 		-- the node that the cursor was in when changeChoice was called exists
-- 		-- in the active choice! Enter it and all nodes between it and this choiceNode,
-- 		-- then set the cursor.
-- 		node_util.enter_nodes_between(dynamic_node, target_node)
--
-- 		if insert_pre_call then
-- 			-- restore cursor-position if the node, or a corresponding node,
-- 			-- could be found.
-- 			-- It is restored relative to the end of the node (as opposed to the
-- 			-- beginning). This does not matter if the text in the node is
-- 			-- unchanged, but if the length changed, we may move the cursor
-- 			-- relative to its immediate neighboring characters.
-- 			-- I assume that it is more likely that the text before the cursor
-- 			-- got longer (since it is very likely that the cursor is just at
-- 			-- the end of the node), and thus restoring relative to the
-- 			-- beginning would shift the cursor back.
-- 			--
-- 			-- However, restoring to any fixed endpoint is likely to not be
-- 			-- perfect, an interesting enhancement would be to compare the new
-- 			-- and old text/[neighborhood of the cursor], and find its new position
-- 			-- based on that.
-- 			util.set_cursor_0ind(
-- 				util.pos_add(
-- 					target_node.mark:get_endpoint(1),
-- 					cursor_pos_end_relative
-- 				)
-- 			)
-- 		else
-- 			node_util.select_node(target_node)
-- 		end
-- 		-- set the new current node correctly.
-- 		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = target_node
-- 	else
-- 		-- the marked node wasn't found, just jump into the new snippet noremally.
-- 		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = dynamic_node.snip:jump_into(1)
-- 	end
-- end
--
-- local function column_count_from_string(descr)
-- 	-- this won't work for all cases, but it's simple to improve
-- 	-- (feel free to do so! :D )
-- 	return #(descr:gsub("[^clm]", ""))
-- end
--
-- -- function for the dynamicNode.
-- local tab = function(args, snip)
-- 	local cols = column_count_from_string(args[1][1])
-- 	-- snip.rows will not be set by default, so handle that case.
-- 	-- it's also the value set by the functions called from dynamic_node_external_update().
-- 	if not snip.rows then
-- 		snip.rows = 1
-- 	end
-- 	local nodes = {}
-- 	-- keep track of which insert-index we're at.
-- 	local ins_indx = 1
-- 	for j = 1, snip.rows do
-- 		-- use restoreNode to not lose content when updating.
-- 		table.insert(nodes, r(ins_indx, tostring(j).."x1", i(1)))
-- 		ins_indx = ins_indx+1
-- 		for k = 2, cols do
-- 			table.insert(nodes, t" & ")
-- 			table.insert(nodes, r(ins_indx, tostring(j).."x"..tostring(k), i(1)))
-- 			ins_indx = ins_indx+1
-- 		end
-- 		table.insert(nodes, t{"\\\\", ""})
-- 	end
-- 	-- fix last node.
-- 	nodes[#nodes] = t""
-- 	return sn(nil, nodes)
-- end

return {
  s( --
    {trig=",env", snippetType="autosnippet", dscr="Expands 'env' into an environment"},
    fmta(
       [[
         \begin{<>}
             <>
         \end{<>}
       ]],
       {
        i(1),
        i(2),
        rep(1),
      }
    )
  ),

  s(
    {trig=",fr", snippetType="autosnippet", dscr="Expands 'fr' into a frame"},
    fmta(
      [[
        \begin{frame}
          \frametitle{<>}
          \framesubtitle{\insertsection}

          <>
        \end{frame}
        <>
      ]],
      {
        i(1),
        i(2),
        i(3),
      }
    )
  ),

  s(
    {trig=",ni", snippetType="autosnippet", dscr="Expands 'ni' to a note item for a beamer slide"},
    fmta(
      [[
        \note[item]<<<>>>{
          <>
        }
        <>
      ]],
      {
      i(1),
      i(2),
      i(3),
      }
    )
  ),

  s(
    {trig=",cl", snippetType="autosnippet", dscr="Expands 'cl' into a columns environment"},
    fmta(
      [[
        \begin{columns}[c]
          \begin{column}{<>\textwidth}
          <>
          \end{column}
          \begin{column}{<>\textwidth}
          <>
          \end{column}
        \end{columns}
        <>
      ]],
      {
        i(1, "0.5"),
        i(2),
        i(3, "0.5"),
        i(4),
        i(5)
      }
    )
  ),

  s(
    {trig=",fig", snippetType="autosnippet", dscr="Expands 'fig' into a figure"},
    fmta(
       [[
         \begin{figure}
          <>
         \end{figure}
       ]],
       {
        i(1),
      }
    )
  ),

  s(
    {trig=",ta", snippetType="autosnippet", dscr="Expands 'ta' into a table"},
    fmta(
      [[
         \begin{table}[<>]
          \centering
          \begin{tabular}{<>}
            <>
          \end{tabular}
          \caption{<>}
          \label{tab:<>}
         \end{table}
      ]],
       {
        i(1),
        i(2, "c|c"),
        i(3),
        i(5),
        i(4)
      }
    )
  ),

  s(
    {trig=",row", snippetType="autosnippet", dscr="Expands 'ta' into a table"},
    fmta(
      [[
        \multirow{4}{*}{<>}  &
        Probing                   &
        \multirow{4}{*}{<>}       &
        \multirow{4}{*}{<>}       &
        \num{102.4e6}             &
        <>                        &
        <>                        &
        <>                        \\
          & NI      &  &  & \num{102.4e6} & <>  & <> & <> \\
          & SNI     &  &  & \num{102.4e6} & <>  & <> & <> \\
          & PINI    &  &  & \num{102.4e6} & <>  & <> & <> \\ <>

      ]],
       {
        i(1),
        i(2),
        i(3),
        i(4),
        i(5),
        i(6),
        i(7),
        i(8),
        i(9),
        i(10),
        i(11),
        i(12),
        i(13),
        i(14),
        i(15),
        i(16),
      }
    )
  ),
  -- TEST
  -- s("tab", fmt([[
  -- \begin{{tabular}}{{{}}}
  -- {}
  -- \end{{tabular}}
  -- ]], {i(1, "c"), d(2, tab, {1}, {
  --   user_args = {
  --     -- Pass the functions used to manually update the dynamicNode as user args.
  --     -- The n-th of these functions will be called by dynamic_node_external_update(n).
  --     -- These functions are pretty simple, there's probably some cool stuff one could do
  --     -- with `ui.input`
  --     function(snip) snip.rows = snip.rows + 1 end,
  --     -- don't drop below one.
  --     function(snip) snip.rows = math.max(snip.rows - 1, 1) end
  --   }
  -- } )})),

  s(
    {trig=",tikz", snippetType="autosnippet", dscr="Expands 'tikz' into a tikzpicture inside a figure"},
    fmta(
      [[
        \begin{figure}
            \centering
            \begin{tikzpicture}
              <>
            \end{tikzpicture}
        \end{figure}
      ]],
       {
        i(1),
      }
    )
  ),

  s(
    {trig=",ol", snippetType="autosnippet", dscr="Enumeration"},
    fmta(
      [[
        \begin{enumerate}
          \item <>
          <>
        \end{enumerate}
      ]],
      { i(1), i(2) }
    )
  ),

  s(
    {trig=",ul", snippetType="autosnippet", dscr="Itemize"},
    fmta(
      [[
        \begin{itemize}
          \item <>
          <>
        \end{itemize}
      ]],
       { i(1), i(2) }
    )
  ),

  s(
    {trig=",des", snippetType="autosnippet", dscr="Description"},
    fmta(
      [[
        \begin{description}
          \item <>
          <>
        \end{description}
      ]],
       { i(1), i(2) }
    )
  ),



  s(
    {trig=",li", snippetType="autosnippet", dscr="List Item"},
    fmta(
       [[
        \item <>
       ]],
       { i(1) }
    )
  ),

  -- Math environment
  s(
    {trig=",eq", snippetType="autosnippet", dscr="Expands 'eq' into an equation environment"},
    fmta(
       [[
         \begin{equation*}
             <>
         \end{equation*}
       ]],
       { i(1) }
    )
  ),

  s(
    {trig=",def", snippetType="autosnippet", dscr="Expands 'def' into an definition environment"},
    fmta(
       [[
         \begin{definition}\label{def:<>}
             <>
         \end{definition}
       ]],
       { i(1), i(2) }
    )
  ),


}
